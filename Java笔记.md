##  第一章  Java 基础

### 1. Hello World程序

``` java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### 2. 数据类型

​	Java提供了多种数据类型，包括基本数据类型和引用数据类型。基本数据类型用于存储简单的数据值，而引用数据类型用于存储对象的引用。

  #### 2.1 基本数据类型

​	Java的基本数据类型包括整数类型、浮点类型、字符类型和布尔类型。每种基本数据类型都有固定的字节大小和表示范围。

  | 数据类型 | 字节大小 | 数据范围                                                |
  | -------- | -------- | ------------------------------------------------------- |
  | byte     | 1        | -128 到 127                                             |
  | short    | 2        | -32,768 到 32,767                                       |
  | int      | 4        | -2,147,483,648 到 2,147,483,647                         |
  | long     | 8        | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
  | float    | 4        | 单精度浮点数，可精确到小数点后7位                       |
  | double   | 8        | 双精度浮点数，可精确到小数点后15位                      |
  | char     | 2        | Unicode字符，范围为 '\u0000' 到 '\uffff'                |
  | boolean  | 1        | true 或 false                                           |

  #### 2.2 自动类型转换和强制类型转换

​	在Java中，基本数据类型之间存在自动类型转换和强制类型转换的机制。

  - **自动类型转换**：当将一个小范围的数据类型赋值给一个大范围的数据类型时，会发生自动类型转换。例如，将一个`int`类型的值赋值给`long`类型的变量时，会自动进行转换。

  ```java
  int x = 5;
  long y = x; // 自动类型转换，将int转换为long
  ```

  - **强制类型转换**：当需要将一个大范围的数据类型转换为小范围的数据类型时，需要使用强制类型转换。强制类型转换可能会导致数据丢失或溢出，因此需要注意。

  ```java
  double a = 3.14;
  int b = (int) a; // 强制类型转换，将double转换为int
  ```

​	需要注意的是，在进行强制类型转换时，应确保转换的数据在目标类型的范围内，以避免数据损失或错误的结果。

  #### 2.3 引用数据类型

​	Java中的引用数据类型用于存储对象的引用，而不是直接存储对象本身。引用数据类型包括类（Class）、接口（Interface）和数组（Array）。

  - **类（Class）**：类是一种自定义的数据类型，用于创建对象。类定义了
  
  - 对象的属性和方法，并可以根据类创建多个对象。
  
    ```java
    class Person {
        String name;
        int age;
    
        void display() {
            System.out.println("Name: " + name + ", Age: " + age);
        }
    }
    ```
  
    - **接口（Interface）**：接口是一种抽象数据类型，定义了一组方法的规范。类可以实现接口，并提供实现接口中定义的方法。
    
    ```java
    interface Drawable {
        void draw();
    }
    ```
  
    - **数组（Array）**：数组是一种用于存储多个相同类型数据的容器。数组可以是一维、二维或多维的，并且具有固定的大小。
    
    ```java
    int[] numbers = {1, 2, 3, 4, 5};
    String[] names = {"Alice", "Bob", "Charlie"};
    ```
  
    引用数据类型在内存中存储对象的引用地址，而对象本身存储在堆内存中。通过引用可以操作对象的属性和调用对象的方法。
  
    ```java
    Person person = new Person();
    person.name = "Alice";
    person.age = 25;
    person.display(); // 调用对象的方法
    ```
  
    需要注意的是，引用数据类型的赋值实际上是将引用复制给另一个引用变量，而不是复制对象本身。
  
    ```java
    Person person1 = new Person();
    Person person2 = person1; // 将person1的引用复制给person2
    ```

  #### 2.4 标识符命名规范和注释

   在Java中，标识符用于命名变量、方法、类等程序元素。标识符必须遵循一定的命名规范：

- 标识符由字母、数字、下划线和美元符号组成。
- 标识符的第一个字符必须是字母、下划线或美元符号。
- 标识符区分大小写。
- 标识符不能是Java的关键字或保留字。

示例有效的标识符：`age`, `myVariable`, `_count`, `$value`

### 3. 变量和常量

  #### 3.1 变量

  变量是用于存储数据的内存位置。在Java中，变量具有特定的类型，并且可以在程序执行过程中改变其值。本节将介绍变量的声明、初始化、作用域以及类变量和实例变量的概念。

- 声明变量

  在Java中，声明变量需要指定变量的类型和名称。语法格式如下：

  ```java
  type variableName;
  ```

  其中，`type`表示变量的数据类型，`variableName`表示变量的名称。例如，声明一个整数变量：

  ```java
  int age;
  ```

- 初始化变量

  变量可以在声明时初始化，也可以在稍后的代码中进行初始化。初始化变量即为变量赋予初始值。示例：

  ```java
  int age = 25; // 在声明时初始化变量
  ```

  或者：

  ```java
  int age; // 声明变量
  age = 25; // 在稍后的代码中初始化变量
  ```

- 变量的作用域

  变量的作用域指的是变量在程序中可见的范围。在Java中，变量的作用域可以是方法内部、方法参数、代码块或类的成员变量。

  - **方法内部变量**：在方法内部声明的变量只在方法内部可见。

  ```java
  void calculate() {
      int result = 0; // 方法内部变量
      // ...
  }
  ```

  - **方法参数**：方法参数是在方法声明中指定的变量，用于接收调用方法时传递的参数。

  ```java
  void printName(String name) {
      // ...
  }
  ```

  - **代码块变量**：在代码块中声明的变量只在代码块内部可见。

  ```java
  {
      int count = 0; // 代码块变量
      // ...
  }
  ```

  - **类的成员变量**：类的成员变量属于类的实例，可以在整个类中访问。

  ```java
  class Person {
      String name; // 类的成员变量
      // ...
  }
  ```

- 类变量和实例变量

  在Java中，类的成员变量可以分为类变量和实例变量。

  - **类变量**：类变量是使用`static`关键字声明的变量，它属于整个类而不是类的实例。类变量在类的所有实例之间共享。

  ```java
  class Counter {
      static int count; // 类变量
      // ...
  }
  ```

  - **实例变量**：实例变量是在类中声明的非静态变量，每个类的实例都有自己的一份实例变量。

  ```java
  class Person {
      String name; // 实例变量
      int age; // 实例变量
      // ...
  }
  ```
  #### 3.1 变量

  常量是在程序执行过程中不可更改的值。在Java中，使用关键字`final`声明常量。常量一旦被赋值后，其值不能再被修改。

- 声明常量

  在Java中，声明常量需要使用`final`关键字，并遵循命名规范。通常使用大写字母表示常量的名称。

  ```java
  final dataType CONSTANT_NAME = value;
  ```

  其中，`dataType`表示常量的数据类型，`CONSTANT_NAME`表示常量的名称，`value`表示常量的初始值。示例：

  ```java
  final double PI = 3.14159;
  ```

- 常量的命名规范

  常量的命名规范与变量的命名规范相似，但常量通常使用全大写字母，并使用下划线分隔单词。

  ```java
  final int MAX_VALUE = 100;
  ```

- 常量的使用

  常量可以在程序中使用，但不能修改其值。常量的主要作用是定义程序中的固定值，提高代码的可读性和维护性。

  ```java
  final int MAX_VALUE = 100;
  int number = 50;
  if (number > MAX_VALUE) {
      // ...
  }
  ```

  常量的值在程序执行期间保持不变，这意味着常量在多处使用时可以确保值的一致性，方便维护和修改。
### 4. 标识符的命名规范

在Java中，标识符是用来给类、方法、变量、常量等命名的。以下是标识符的命名规范：

- 标识符可以包含字母、数字和下划线（_），但不能以数字开头。
- 标识符区分大小写，例如，`myVariable`和`myvariable`是不同的标识符。
- 标识符不能是Java的关键字和保留字，如`public`、`class`、`void`等。
- 标识符应具有描述性，能够清晰表达其用途和含义。
- 通常使用驼峰命名法来命名标识符，即首字母小写，后续单词首字母大写，如`myVariableName`。

### 5. 运算符

- 运算符是用于执行特定操作的符号或关键字。在Java中，有多种类型的运算符，包括算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符和其他运算符。本节将介绍这些运算符的使用和优先级。


#### 5.1 算术运算符

| 运算符 | 描述     |
| ------ | -------- |
| +      | 加法     |
| -      | 减法     |
| *      | 乘法     |
| /      | 除法     |
| %      | 取模运算 |

#### 5.2 赋值运算符

| 运算符 | 描述     |
| ------ | -------- |
| =      | 简单赋值 |
| +=     | 加法赋值 |
| -=     | 减法赋值 |
| *=     | 乘法赋值 |
| /=     | 除法赋值 |
| %=     | 取模赋值 |

#### 5.3 比较运算符

| 运算符 | 描述     |
| ------ | -------- |
| ==     | 相等     |
| !=     | 不等     |
| >      | 大于     |
| <      | 小于     |
| >=     | 大于等于 |
| <=     | 小于等于 |

#### 5.4 逻辑运算符

| 运算符 | 描述   |
| ------ | ------ |
| &&     | 短路与 |
| \|\|   | 短路或 |
| !      | 非     |

#### 5.5 位运算符

| 运算符 | 描述       |
| ------ | ---------- |
| &      | 位与       |
| \|     | 位或       |
| ^      | 位异或     |
| ~      | 位非       |
| <<     | 左移       |
| >>     | 右移       |
| >>>    | 无符号右移 |

#### 5.6 关系运算符

| 运算符 | 描述     |
| ------ | -------- |
| ==     | 相等     |
| !=     | 不等     |
| >      | 大于     |
| <      | 小于     |
| >=     | 大于等于 |
| <=     | 小于等于 |

#### 5.7 递增和递减运算符

| 运算符 | 描述 |
| ------ | ---- |
| ++     | 递增 |
| --     | 递减 |

#### 5.8 三目运算符

| 运算符 | 描述                     |
| ------ | ------------------------ |
| ? :    | 条件运算符（三目运算符） |

#### 5.9 运算符的优先级

在表达式中，运算符具有不同的优先级。具有较高优先级的运算符会先于具有较低优先在表达式中，运算符具有不同的优先级。具有较高优先级的运算符会先于具有较低优先级的运算符进行计算。如果存在相同优先级的运算符，会根据结合性决定计算顺序。

下表按照优先级从高到低列出了常见的运算符：

| 运算符                | 描述                           |
| --------------------- | ------------------------------ |
| ()                    | 括号（用于改变运算符的优先级） |
| ++, --                | 递增和递减运算符               |
| !                     | 逻辑非运算符                   |
| *, /, %               | 乘法、除法和取模运算符         |
| +, -                  | 加法和减法运算符               |
| <<, >>, >>>           | 左移、右移和无符号右移运算符   |
| <, <=, >, >=          | 关系运算符                     |
| ==, !=                | 相等性运算符                   |
| &                     | 位与运算符                     |
| ^                     | 位异或运算符                   |
| \|                    | 位或运算符                     |
| &&                    | 短路与运算符                   |
| \|\|                  | 短路或运算符                   |
| ?:                    | 条件运算符（三目运算符）       |
| =, +=, -=, *=, /=, %= | 赋值运算符                     |

请注意，以上表格中的运算符顺序是按照优先级从高到低排列的，具有相同优先级的运算符按照结合性从左到右计算。

Java中，赋值运算符（包括简单赋值运算符和复合赋值运算符）是右结合性的，而不是按照从左到右的结合性。

右结合性意味着赋值运算符计算顺序是从右往左进行的。

例如，考虑以下示例：

```java
int a = 5;
int b = 10;
int c = 15;

// 右结合性，从右往左计算
int result = a + (b = c); // 先将b赋值为c，再计算a + b，最终result的值为25
```

在上述示例中，表达式`b = c`先执行，将变量b的值赋为变量c的值，然后再将`a + b`的结果赋给变量result。

### 6. 控制流程

在编程中，流程控制语句用于控制程序的执行流程，根据条件进行判断和重复执行特定的代码块。Java 提供了多种流程控制语句，包括条件语句、循环语句和跳转语句。

#### 6.1 条件语句

条件语句根据条件的真假来选择性地执行代码块。

- if 语句

```java
if (条件) {
    // 如果条件为真，执行这里的代码块
}
```

- `条件` 是一个布尔表达式，用于判断是否执行代码块。
- 如果 `条件` 为真，将执行 `if` 代码块中的代码。
- 如果 `条件` 为假，将跳过 `if` 代码块，继续执行后续的代码。

- if-else 语句

```java
if (条件) {
    // 如果条件为真，执行这里的代码块
} else {
    // 如果条件为假，执行这里的代码块
}
```

- `条件` 是一个布尔表达式，用于判断执行哪个代码块。
- 如果 `条件` 为真，将执行 `if` 代码块中的代码。
- 如果 `条件` 为假，将执行 `else` 代码块中的代码。

- switch 语句

```java
switch (表达式) {
    case 值1:
        // 如果表达式的值等于值1，执行这里的代码块
        break;
    case 值2:
        // 如果表达式的值等于值2，执行这里的代码块
        break;
    default:
        // 如果表达式的值与前面的值都不匹配，执行这里的代码块
        break;
}
```

- `表达式` 是一个可以产生整数、字符或枚举类型值的表达式。
- 根据 `表达式` 的值，选择匹配的 `case` 分支执行相应的代码块。
- 如果找到匹配的分支，则执行该分支的代码块，并使用 `break` 语句跳出 `switch` 语句。
- 如果没有找到匹配的分支，则执行 `default` 分支的代码块（可选）。

#### 6.2 循环语句

循环语句用于重复执行特定的代码块，直到满足退出条件为止。

- while 循环

```java
while (条件) {
    // 只要条件为真，重复执行这里的代码块
}
```

- `条件` 是一个布尔表达式，用于判断是否继续执行循环。

- 只要 `条件` 为真，就会重复执行 `while` 循环中的代码块。

- 在

- 循环执行代码块之前和之后，都会检查 `条件` 的值。如果 `条件` 为假，则退出循环，继续执行后续的代码。

- do-while 循环

```java
do {
    // 先执行这里的代码块
} while (条件);
```

- `条件` 是一个布尔表达式，用于判断是否继续执行循环。
- 先执行 `do` 代码块中的代码，然后再检查 `条件` 的值。
- 只要 `条件` 为真，就会重复执行 `do-while` 循环中的代码块。
- 在循环执行代码块之前和之后，都会检查 `条件` 的值。如果 `条件` 为假，则退出循环，继续执行后续的代码。


- for 循环

```java
for (初始化语句; 条件; 更新语句) {
    // 只要条件为真，重复执行这里的代码块
}
```

- `初始化语句` 用于初始化循环控制变量。
- `条件` 是一个布尔表达式，用于判断是否继续执行循环。
- `更新语句` 用于更新循环控制变量的值。
- 在执行完 `初始化语句` 后，先检查 `条件` 的值。只要 `条件` 为真，就会重复执行 `for` 循环中的代码块。
- 在每次循环结束后，执行 `更新语句` 来更新循环控制变量的值。


#### 6.3 跳转语句

跳转语句用于在程序执行过程中改变执行的顺序。

- break 语句

`break` 语句用于跳出当前的循环或 `switch` 语句。

```java
while (条件) {
    if (某个条件) {
        break; // 跳出循环
    }
    // 其他代码
}
switch (表达式) {
    case 值1:
        // 代码块
        break; // 跳出 switch 语句
    case 值2:
        // 代码块
        break; // 跳出 switch 语句
    default:
        // 代码块
        break; // 跳出 switch 语句
}
```

- continue 语句

`continue` 语句用于跳过当前循环中剩余的代码，直接进入下一次循环。

```java
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue; // 跳过当前循环的剩余代码，进入下一次循环
    }
    // 其他代码
}
```

- return 语句

`return` 语句用于从方法中返回值，并终止方法的执行。

```java
public int calculateSum(int a, int b) {
    int sum = a + b;
    return sum; // 返回 sum 的值并结束方法的执行
}
```

- 在方法中使用 `return` 语句可以返回一个值，并将该值传递给调用方法的地方。
- `return` 语句也可以用于提前终止方法的执行，即使没有返回值。


- goto 语句

`goto` 语句在 Java 中不被支持，不推荐使用。

- 控制流程语句的嵌套

在 Java 中，控制流程语句可以相互嵌套，形成复杂的逻辑。

```java
if (条件1) {
    // 代码块1
    if (条件2) {
        // 代码块2
    } else {
        // 代码块3
    }
} else {
    // 代码块4
}
```

- 在上述示例中，`if` 语句嵌套在另一个 `if` 语句中，形成了嵌套的控制流程语句。
- 嵌套的控制流程语句可以根据条件的组合执行不同的代码块，提供了更灵活的控制流程。

注意：嵌套的控制流程语句应谨慎使用，过多的嵌套可能导致代码难以理解和维护。尽量使用简洁明了的逻辑结构，避免过深的嵌套。

### 7. 数组

数组是一种用于存储多个相同类型元素的数据结构。在 Java 中，数组具有固定长度，并且可以在声明时或运行时初始化。使用数组可以方便地管理和操作大量数据。

  #### 7.1 声明和初始化数组

  在 Java 中，声明数组需要指定数组的类型和长度。数组的长度确定后，无法再次更改。

- 声明数组

  ```java
  // 声明一个整型数组
  int[] numbers;
  
  // 声明一个字符串数组
  String[] names;
  ```

 - 初始化数组

--  静态初始化

  静态初始化是指在声明数组的同时，直接为数组元素赋值。

  ```java
  // 静态初始化整型数组
  int[] numbers = {1, 2, 3, 4, 5};
  
  // 静态初始化字符串数组
  String[] names = {"Alice", "Bob", "Charlie"};
  ```

--  动态初始化

  动态初始化是指在声明数组后，通过指定数组长度来分配内存空间，并逐个为数组元素赋初值。

  ```java
  // 动态初始化整型数组
  int[] numbers = new int[5];
  numbers[0] = 1;
  numbers[1] = 2;
  numbers[2] = 3;
  numbers[3] = 4;
  numbers[4] = 5;
  
  // 动态初始化字符串数组
  String[] names = new String[3];
  names[0] = "Alice";
  names[1] = "Bob";
  names[2] = "Charlie";
  ```

  #### 7.2 访问数组元素

  数组元素的访问通过索引（下标）来实现，索引从 0 开始，依次递增。

  ```java
  int[] numbers = {1, 2, 3, 4, 5};
  int firstNumber = numbers[0]; // 访问第一个元素
  int thirdNumber = numbers[2]; // 访问第三个元素
  ```

  #### 7.3 数组长度

  可以使用 `length` 属性获取数组的长度，该属性返回数组中元素的个数。

  ```java
  int[] numbers = {1, 2, 3, 4, 5};
  int length = numbers.length; // 获取数组长度
  ```

  #### 7.4 遍历数组

  可以使用循环结构遍历数组，访问数组的每个元素。

- for 循环遍历数组

  ```java
  int[] numbers = {1, 2, 3, 4, 5};
  for (int i = 0; i < numbers.length; i++) {
      int number = numbers[i]; // 获取当前元素
      // 执行相应操作
  }
  ```

 - 增强型 for 循环遍历数组

  增强型 for 循环（也称为 for-each 循环）适用于遍历数组的所有元素。

  ```java
  
  int[] numbers = {1, 2, 3,4, 5};
  for (int number : numbers) {
      // 执行相应操作，number 为当前元素的值
  }
  ```
  #### 7.5 多维数组

  除了一维数组，Java 还支持多维数组，即数组中包含数组。

- **声明和初始化多维数组**

  ```java
  // 声明一个二维整型数组
  int[][] matrix;
  
  // 声明一个三维字符串数组
  String[][][] cube;
  ```

  多维数组的初始化可以通过嵌套的方式进行。

  ```java
  // 静态初始化二维整型数组
  int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  
  // 静态初始化三维字符串数组
  String[][][] cube = {
      {
          {"A1", "A2"},
          {"A3", "A4"}
      },
      {
          {"B1", "B2"},
          {"B3", "B4"}
      }
  };
  ```

- **访问多维数组元素**

  通过多个索引来访问多维数组的元素。

  ```java
  int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  int element = matrix[1][2]; // 访问第二行第三列的元素
  ```

- **遍历多维数组**

  可以使用嵌套的循环结构遍历多维数组的所有元素。

  ```java
  int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  for (int i = 0; i < matrix.length; i++) {
      for (int j = 0; j < matrix[i].length; j++) {
          int element = matrix[i][j]; // 获取当前元素
          // 执行相应操作
      }
  }
  ```


#### 7.6 数组的常见操作

在使用数组时，还可以进行一些常见的操作，如复制数组、排序数组等。

- 复制数组

  可以使用 `System.arraycopy()` 方法或使用循环逐个复制数组元素来复制数组。

  ```java
  int[] source = {1, 2, 3, 4, 5};
  int[] target = new int[source.length];
  
  // 使用 System.arraycopy() 方法复制数组
  System.arraycopy(source, 0, target, 0, source.length);
  
  // 使用循环逐个复制数组元素
  for (int i = 0; i < source.length; i++) {
      target[i] = source[i];
  }
  ```

- 排序数组

  可以使用 `Arrays.sort()` 方法对数组进行排序。

  ```java
  int[] numbers = {5, 3, 1, 4, 2};
  Arrays.sort(numbers); // 对数组进行排序
  ```


#### 7.7 数组的限制和注意事项

- 数组在声明
- 时需要指定类型和长度，且长度一旦确定后无法更改。
- 数组的索引从0开始，最大索引为长度减1，访问数组元素时要注意不越界。
- 数组可以存储任意类型的元素，包括基本数据类型和引用数据类型。
- 数组的长度可以通过 `length` 属性获取，但是数组对象本身没有长度属性。
- 数组可以是一维或多维的，多维数组由多个一维数组组成。
- 数组可以通过静态初始化或动态初始化来赋值。
- 数组的元素可以通过索引进行访问和修改。
- 数组可以使用循环结构遍历数组元素。
- 复制数组可以使用 `System.arraycopy()` 方法或循环逐个复制元素。
- 数组可以使用 `Arrays.sort()` 方法对元素进行排序。

需要注意的是，数组的长度有限制，由 JVM 的实现和运行环境决定。在创建数组时，需要确保所需的内存不超过系统可用内存，否则会抛出 `OutOfMemoryError` 异常。另外，数组在内存中是连续存储的，因此当数组元素过多时可能会导致内存空间不足的问题。

此外，当使用数组时，还需要注意空指针异常（`NullPointerException`）的问题。如果没有正确初始化数组或访问了一个为 `null` 的数组引用，都会导致空指针异常的发生。在使用数组前，应确保数组已经被正确初始化。

### 8. 方法

方法是一段封装了特定功能的代码块，可以通过方法名和参数列表来调用执行。在 Java 中，方法用于实现代码的模块化、重用和组织。本节将介绍方法的声明、调用、参数、返回值、重载和递归等相关内容。

#### 8.1 方法的声明和定义

方法的声明和定义包括方法名、参数列表、返回类型和方法体的结构。方法的声明告诉编译器方法的存在和如何调用它，方法的定义则提供了方法的具体实现。

```java
// 方法的声明
返回类型 方法名(参数列表) {
    // 方法体
    // 执行相应操作
}

// 方法的定义
返回类型 方法名(参数列表) {
    // 方法体
    // 执行相应操作
    return 返回值; // 可选，如果方法有返回值的话
}
```

其中：

- 返回类型指定了方法执行后的返回结果类型，可以是基本数据类型或引用数据类型。如果方法没有返回值，返回类型应为 `void`。
- 方法名是用于标识方法的名称，应符合命名规范。
- 参数列表是一组以逗号分隔的参数，用于接收调用方法时传递的值。参数列表可以为空，也可以包含一个或多个参数。
- 方法体包含了实现方法功能的代码块。

示例：

```java
// 无返回值的方法，不带参数
public void greet() {
    System.out.println("Hello, world!");
}

// 有返回值的方法，带参数
public int add(int a, int b) {
    int sum = a + b;
    return sum;
}
```

#### 8.2 方法的调用

调用方法是通过方法名和参数列表来执行方法的过程。调用方法时，根据方法名和参数列表的匹配来确定要调用的方法。

```java
// 调用无返回值的方法
方法名(参数列表);

// 调用有返回值的方法
数据类型 变量名 = 方法名(参数列表);
```

示例：

```java
// 调用无返回值的方法
greet();

// 调用有返回值的方法
int result = add(3, 5);
System.out.println("Result: " + result);
```

#### 8.3 方法的参数

方法的参数用于接收调用方法时传递的值。参数列表是一组以逗号分隔的参数，每个参数由参数类型和参数名组成。方法在执行时可以使用这些参数进行计算和处理。

```java
// 无参数的方法
public void methodName() {
    // 执行相应操作
}

// 带参数的方法
public void methodName(参数类型 参数名) {
    // 执行相应操作，可以使用参数进行计算和处理
}
```

示例：

```java
// 带参数的方法
public void greet(String name) {
    System.out.println("Hello, " + name + "!");
}

// 调用带参数的方法
greet("John");
```

#### 8.4 方法的返回值

方法的返回值是方法执行后的结果，可以是基本数据类型或引用数据类型。在方法定义时，通过返回类型来指定方法的返回值类型。方法可以使用 `return` 语句将结果返回给调用方。

```java
// 无返回值的方法
public void methodName() {
    // 执行相应操作
}

// 有返回值的方法
public 返回类型 methodName() {
    // 执行相应操作
    return 返回值;
}
```

示例：

```java
// 有返回值的方法
public int add(int a, int b) {
    int sum = a + b;
    return sum;
}

// 调用有返回值的方法
int result = add(3, 5);
System.out.println("Result: " + result);
```

#### 8.5 方法的重载

方法重载是指在同一个类中可以定义多个同名但参数列表不同的方法。通过方法的参数列表的不同来区分不同的方法，可以根据不同的需求来实现类似功能但具有不同参数的方法。

方法重载的条件：

- 方法名相同。
- 参数列表不同（参数个数、参数类型或参数顺序不同）。

示例：

```java
// 重载的方法
public void greet() {
    System.out.println("Hello!");
}

public void greet(String name) {
    System.out.println("Hello, " + name + "!");
}

public void greet(String name, int age) {
    System.out.println("Hello, " + name + "! You are " + age + " years old.");
}
```

#### 8.6 方法的递归

方法递归是指在方法体内部调用自身的过程。递归方法可以用于解决需要重复执行相似操作的问题。在递归过程中，每次调用方法时都会将参数不断传递下去，直到达到递归终止条件才会停止递归。

递归方法必须包含递归终止条件，否则会导致无限递归，最终抛出 `StackOverflowError` 异常。

示例：

```java
public int factorial(int n) {
    if (n == 0 || n == 1) {
        return 1; // 递归终止条件
    } else {
        return n * factorial(n - 1); // 递归调用自身
    }
}
```

#### 8.7 方法的作用域

方法的作用域指的是方法内部声明的变量的可见范围。在方法中声明的变量只能在方法内部访问，不能在其他方法中直接使用。

方法的作用域可以分为两种情况：

- 局部变量：在方法内部声明的变量，只在方法内部有效。
- 方法参数：作为方法的输入，只在方法内部有效。

示例：

```java
public void methodName() {
    int localVar = 10; // 方法内的局部变量
    System.out.println(localVar);
}

public void methodName() {
    int localVar = 10; // 方法内的局部变量
    System.out.println(localVar);
}

public void anotherMethod(int parameter) {
    System.out.println(parameter);
}

public void main(String[] args) {
    methodName(); // 调用方法，输出：10
    
    int value = 20;
    anotherMethod(value); // 调用方法，输出：20
}
```

在上面的示例中，`methodName` 方法内部声明了一个局部变量 `localVar`，只能在该方法内部访问。而 `anotherMethod` 方法有一个参数 `parameter`，该参数只在该方法内部有效。在 `main` 方法中调用了这两个方法，并传递了相应的参数。通过方法调用，可以在方法内部访问局部变量和方法参数。

请注意，方法的作用域仅限于方法内部，无法在其他方法中直接使用。每个方法都有自己独立的作用域，变量的生命周期仅限于所属的方法内部。

#### 8.8 方法的可变参数

可变参数是指方法的参数个数是可变的，可以接受不定数量的参数。在方法的参数列表中使用三个连续的点（...）表示可变参数。

可变参数的特点：

- 可变参数必须是方法参数列表中的最后一个参数。
- 可变参数可以接受任意数量的参数，包括零个参数。
- 在方法内部，可变参数被当作数组来处理。

示例：

```java
public void printNumbers(int... numbers) {
    for (int num : numbers) {
        System.out.println(num);
    }
}

// 调用方法
printNumbers(1, 2, 3); // 输出：1 2 3
printNumbers(); // 输出：（无输出）
```

#### 8.9 方法的重写

方法重写是指在子类中重新定义父类中已有的方法。重写的方法具有相同的方法名、参数列表和返回类型。子类通过重写父类的方法来改变方法的实现逻辑，以满足子类的特定需求。

重写方法的要求：

- 方法名、参数列表和返回类型与父类方法相同。
- 子类方法的访问修饰符不能比父类方法的访问修饰符更严格（可以更宽松）。
- 子类方法的返回类型必须是父类方法返回类型的子类型（或相同类型）。
- 子类方法不能抛出比父类方法更宽泛的受检异常。

示例：

```java
// 父类
public class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}

// 子类
public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating bones.");
    }
}
```

#### 8.10 方法的重载与重写的区别

方法重载和方法重写是两个不同的概念和用途。

方法重载（Overloading）指的是在同一个类中可以定义多个同名但参数列表不同的方法。方法重载通过参数列表的不同来区分方法，可以根据不同的需求来实现类似功能但具有不同参数的方法。

方法重写（Overriding）指的是在子类中重新定义父类中已有的方法。重写的方法具有相同的方法名、参数列表和返回类型。通过重写父类的方法，子类可以改变方法的实现逻辑，以满足子类的特定需求。

区别：

- 方法重载发生在同一个类中，方法重写发生在子类中。
- 方法重载是通过参数列表的不同来区分方法，方法重写是通过继承关系来定义父类和子类之间的方法关系。
- 方法重载是在编译时静态决定调用哪个方法，方法重写是在运行时动态决定调用哪个方法

#### 8.11 方法的访问修饰符

方法可以使用不同的访问修饰符来限制对方法的访问权限。Java 提供了多种访问修饰符，每种修饰符具有不同的访问级别和作用范围。

常用的方法访问修饰符包括：

- `public`：可以被任意类访问。
- `protected`：可以被同一包内的类和子类访问。
- `private`：只能在同一类内部访问。
- 默认修饰符（无修饰符）：可以被同一包内的类访问。

示例：

```java
public class MyClass {
    public void publicMethod() {
        // 可以被任意类访问
    }
    
    protected void protectedMethod() {
        // 可以被同一包内的类和子类访问
    }
    
    private void privateMethod() {
        // 只能在同一类内部访问
    }
    
    void defaultMethod() {
        // 可以被同一包内的类访问
    }
}
```

#### 8.12 方法的静态与实例

方法可以分为静态方法和实例方法两种类型。

静态方法（Static Method）属于类本身，可以通过类名直接调用，无需创建类的实例对象。静态方法中不能访问非静态成员变量和非静态方法，只能访问静态成员变量和静态方法。

实例方法（Instance Method）属于类的实例对象，需要先创建类的实例对象，然后通过对象调用方法。实例方法可以访问类的实例变量和静态变量，以及其他实例方法和静态方法。

示例：

```java
public class MyClass {
    // 静态方法
    public static void staticMethod() {
        // 执行相应操作
    }
    
    // 实例方法
    public void instanceMethod() {
        // 执行相应操作
    }
}
```

#### 8.13 方法的参数传递

在方法调用过程中，参数可以按值传递给方法。Java 中的参数传递是将实际参数的值复制一份给方法的形式参数，方法内部对形式参数的修改不会影响实际参数的值。

对于基本数据类型的参数，传递的是值的副本，对形式参数的修改不会影响实际参数的值。

对于引用数据类型的参数，传递的是引用的副本，即引用的内存地址，对形式参数的修改会影响实际参数所指向的对象。

示例：

```java
public void modifyValue(int value) {
    value = 100; // 修改形式参数的值，不影响实际参数的值
}

public void modifyArray(int[] array) {
    array[0] = 100; // 修改形式参数所指向的对象，会影响实际参数所指向的对象
}

// 调用方法
int x = 10;
modifyValue(x);
System.out.println(x); // 输出：10

int[] arr = {1, 2, 3};
modifyArray(arr);
System.out.println(arr[0]); // 输出：100
```

#### 8.14 方法的返回值传递

方法的返回值传递指的是方法通过返回值将结果传递给调用方。返回值可以是基本数据类型或引用数据类型。

对于基本数据类型的返回值，返回的是值的副本，方法内部对返回值的修改不会影响调用方的变量。

对于引用数据类型的返回值，返回的是引用的副本，即引用的内存地址，方法内部对返回值所指向对象的修改会影响调用方持有的引用。

示例：

```java
public int calculate() {
    int result = 10;
    return result; // 返回基本数据类型的值的副本
}

public int[] createArray() {
    int[] array = {1, 2, 3};
    return array; // 返回引用数据类型的引用的副本
}

// 调用方法
int x = calculate();
System.out.println(x); // 输出：10

int[] arr = createArray();
arr[0] = 100;
System.out.println(arr[0]); // 输出：100
```

### 9. 注释

在Java中，注释用于解释和说明代码的作用。Java支持三种类型的注释：

- **单行注释**：以`//`开头，注释内容在`//`后面的部分。

```java
// 这是一个单行注释
int x = 5; // 可以在代码行的末尾添加注释
```

- **多行注释**：以`/*`开头，以`*/`结尾，注释内容在`/*`和`*/`之间。

```java
/*
这是一个
多行注释
*/
int y = 10;
```

- **文档注释**：以`/**`开头，以`*/`结尾，用于生成文档。

```java
/**
 * 这是一个文档注释示例。
 * 用于对方法、类或接口进行详细的描述。
 * 可以包含参数说明、返回值说明等。
 * 
 * @param x 参数x的说明
 * @return 返回值的说明
 */
public int myMethod(int x) {
    // 方法体
    return x * 2;
}```
文档注释可以通过工具生成API文档，提供给其他开发者参考和使用。

```

Java中使用注释来提供代码的解释和说明。注释不会被编译器处理，注释对于代码的可读性和维护性非常重要，应该养成良好的注释习惯，对关键代码进行适当的注释解释。

## 第二章：面向对象编程

### 1. 类和对象

#### 1.1 类的定义和声明

类是面向对象编程的基本概念之一，它是对象的模板或蓝图，描述了对象的属性和行为。类的定义和声明包括以下要点：

- 类的语法：使用关键字 `class` 来定义一个类，紧接着是类的名称和类体。
- 类的名称：类的名称应使用大写字母开头，遵循驼峰命名法。
- 类的成员：类的成员包括成员变量和成员方法。
- 成员变量：成员变量是类的属性，用于存储对象的状态。它们可以是基本数据类型或引用数据类型。
- 成员方法：成员方法是类的行为，用于执行特定的操作。它们定义在类中，并且可以被对象调用。

示例：

```java
public class MyClass {
    // 成员变量
    private int myVariable;

    // 成员方法
    public void myMethod() {
        // 方法体
    }
}
```

#### 1.2 对象的创建和使用

对象是类的实例，通过类创建出来并在程序中使用。对象的创建和使用包括以下要点：

- 使用关键字 `new` 创建对象：使用 `new` 关键字后跟类名和括号，可以创建类的实例。
- 对象的赋值：将对象赋值给变量，使变量引用该对象。
- 对象的方法调用：使用对象引用调用对象的方法。

示例：

```java
MyClass myObject = new MyClass(); // 创建 MyClass 类的对象
myObject.myMethod(); // 调用对象的方法
```

#### 1.3 成员变量和成员方法

成员变量和成员方法是类的两个重要组成部分，用于定义类的属性和行为。

- 成员变量：成员变量定义在类中，可以被类的所有方法访问。它们用于存储对象的状态，并可以在类的任何方法中使用。
- 成员方法：成员方法定义了类的行为和操作。它们可以访问类的成员变量，并可以在对象上执行特定的操作。

示例：

```java
public class MyClass {
    // 成员变量
    private int myVariable;

    // 成员方法
    public void myMethod() {
        // 使用成员变量
        System.out.println("My variable: " + myVariable);
    }
}
```

#### 1.4 构造方法和实例化对象

构造方法是一种特殊的方法，用于创建和初始化对象。在实例化对象时，构造方法会被自动调用。构造方法的特点包括：

- 构造方法的名称与类名相同。
- 构造方法没有返回类型，甚至没有 `void`。
- 构造方法可以重载，即可以有多个构造方法，它们具有不同的参数列表。
- 构造方法可以用于初始化成员变量的初始值，执行特定的操作，或者接受外部传入的参数。

示例：

```java
public class MyClass {
    private int myVariable;

    // 默认构造方法
    public MyClass() {
        myVariable = 0; // 初始化成员变量
    }

    // 带参数的构造方法
    public MyClass(int value) {
        myVariable = value; // 使用参数初始化成员变量
    }
}

// 实例化对象
MyClass obj1 = new MyClass(); // 使用默认构造方法创建对象
MyClass obj2 = new MyClass(10); // 使用带参数的构造方法创建对象
```

#### 1.5 方法重载

方法重载是指在一个类中定义多个方法，它们具有相同的名称但不同的参数列表。方法重载的特点包括：

- 方法重载可以根据不同的参数类型、参数个数或参数顺序来区分。
- 方法重载可以有不同的返回类型。
- 方法重载可以提高代码的复用性和灵活性。

示例：

```java
public class MyClass {
    public void myMethod() {
        // 方法没有参数
    }

    public void myMethod(int num) {
        // 方法接受一个整数参数
    }

    public void myMethod(String str) {
        // 方法接受一个字符串参数
    }
}

MyClass obj = new MyClass();
obj.myMethod(); // 调用方法 myMethod()
obj.myMethod(10); // 调用方法 myMethod(int)
obj.myMethod("Hello"); // 调用方法 myMethod(String)
```

#### 1.6 类和对象的内存分配

在Java中，类和对象的内存分配是由JVM（Java虚拟机）负责的。JVM使用一种称为Java内存模型（Java Memory Model）的规范来管理内存的分配和使用。

##### 1.6.1 JVM 内存模型概述

JVM内存模型定义了JVM在运行时如何划分和管理内存。它包括以下几个主要的内存区域：

- 方法区（Method Area）：存储类的信息和静态变量。
- 堆（Heap）：存储对象的实例变量。
- 栈（Stack）：存储方法调用和局部变量。
- 常量池（Constant Pool）：存储常量和符号引用。
- 本地方法栈（Native Method Stack）：用于支持Java程序调用本地方法。

##### 1.6.2 方法区（Method Area）

方法区是JVM的一部分，用于存储类的信息和静态变量。它在JVM启动时被创建，并且在JVM关闭时销毁。方法区是线程共享的，所有线程都可以访问其中的类信息和静态变量。

方法区存储了以下内容：

- 类的字节码（Class Bytecode）：即编译后的Java类文件。
- 常量池（Constant Pool）：存储类中的常量和符号引用。
- 类的静态变量（Static Variables）：类级别的静态变量，不依赖于对象的创建。
- 类的方法（Methods）：类中定义的方法。

##### 1.6.3 堆（Heap）

堆是用于存储对象实例的内存区域。在Java中，所有的对象都存储在堆中，包括通过关键字`new`创建的对象和数组。

堆内存的特点包括：

- 动态分配：在运行时根据对象的创建和销毁进行内存的分配和释放。
- 对象共享：多个引用可以指向同一个对象，实现对象的共享。

##### 1.6.4 栈（Stack）

栈是用于存储方法调用和局部变量的内存区域。每个线程都有自己的栈，用于记录方法的调用和执行过程。

栈内存的特点包括：

- 方法调用：栈通过方法调用的方式来管理程序的执行流程，每次方法调用会创建一个新的栈帧。
- 局部变量：栈帧中包含了方法的局部变量和临时变量。

##### 1.6.5 常量池（Constant Pool）

常量池是存储常量和符号引用的内存区域。它包含了类中的常量、字符串字面值、类和接口的全限定名、字段和方法的符号引用等信息。

常量池的特点包括：

- 存储常量：常量池可以存储整型、浮点型、字符型、布尔型等基本数据类型的常量。
- 存储字符串字面值：字符串字面值在编译时会被放入常量池，从而实现字符串的共享。
- 存储符号引用：常量池存储了类和接口的全限定名、字段和方法的符号引用，用于在运行时解析符号引用。

##### 1.6.6 对象的创建和销毁过程

在Java中，对象的创建和销毁是由JVM自动管理的。当通过`new`关键字创建对象时，JVM会执行以下步骤：

1. 分配内存：JVM在堆中分配一块内存用于存储对象的实例变量。
2. 初始化对象：JVM对对象进行初始化，包括初始化实例变量和调用构造方法。
3. 返回引用：将分配的内存地址作为引用返回，可以通过引用来操作和访问对象。

对象的销毁是由JVM的垃圾回收机制自动处理的。当对象不再被引用时，JVM会自动标记该对象为垃圾，然后在适当的时机回收其所占用的内存。

##### 1.6.7 对象的引用和垃圾回收

在Java中，对象通过引用来进行操作和访问。对象的引用是指向对象的指针，它存储了对象在内存中的地址。

Java中的引用类型包括：

- 普通引用：通过`new`关键字创建的对象引用。
- 静态引用：指向静态变量的引用，存在于方法区中。
- 弱引用、软引用和虚引用：用于对对象进行特殊的引用控制和垃圾回收。

垃圾回收是JVM自动管理内存的过程，通过标记-清除算法和可达性分析等机制来判断哪些对象是不再被引用的垃圾对象，并释放其所占用的内存。

#### 1.7 内部类

在Java中，内部类是指定义在其他类内部的类。内部类可以访问外部类的成员，并且可以提供更加灵活的代码组织和封装。

##### 1.7.1 内部类的分类

内部类可以分为以下几种类型：

1. 静态内部类（Static Inner Class）：定义在外部类内部但被 static 修饰的内部类。静态内部类可以直接通过外部类名访问，并且不依赖于外部类的实例。
2. 成员内部类（Member Inner Class）：定义在外部类内部且不被 static 修饰的内部类。成员内部类的实例必须依赖于外部类的实例。
3. 局部内部类（Local Inner Class）：定义在方法内部或代码块内部的内部类。局部内部类只在其所在的方法或代码块内部可见，对外部是隐藏的。
4. 匿名内部类（Anonymous Inner Class）：没有名字的内部类，通常用作接口实现或继承父类并重写方法的简洁方式。

##### 1.7.2 内部类的特点和用途

内部类具有以下特点和用途：

- 内部类可以访问外部类的私有成员，包括私有字段和私有方法。
- 内部类可以实现类之间的多重继承，即一个类可以继承自多个类。
- 内部类可以实现封装和隐藏，将相关的类和接口组织在一起。
- 内部类可以提供更好的代码结构和可读性，将相关的功能放在一起。
- 内部类可以实现回调和事件处理等功能。

##### 1.7.3 内部类的语法和使用

内部类的语法格式如下：

```java
class OuterClass {
    // 外部类的成员和方法

    class InnerClass {
        // 内部类的成员和方法
    }
}
```

使用内部类时，需要先创建外部类的实例，然后再通过外部类实例来创建内部类的实例。例如：

```java
OuterClass outer = new OuterClass();
OuterClass.InnerClass inner = outer.new InnerClass();
```

内部类的访问修饰符可以是 public、protected、default（包级访问）或 private，用来控制内部类的可见性。

##### 1.7.4 内部类的示例

下面是一个使用内部类的示例，演示了不同类型的内部类的定义和使用：

```java
public class OuterClass {
    private int outerField;

    public void outerMethod() {
        System.out.println("Outer Method");
    }

    // 静态内部类
    public static class StaticInnerClass {
        public void innerMethod() {
            System.out.println("Static Inner Method");
        }
    }

    // 成员内部类
    public class MemberInnerClass {
        public void innerMethod() {
            System.out.println("Member Inner Method");
        }
    }

    public void localClassMethod() {
        // 局部内部类
        class LocalInnerClass {
            public void innerMethod() {
                System.out.println("Local Inner Method");
            }
        }

        LocalInnerClass inner = new LocalInnerClass();
        inner.innerMethod();
    }

    public void anonymousClassMethod() {
        // 匿名内部类
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous Inner Method");
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

在上面的示例中，我们定义了一个外部类 `OuterClass`，并在其中定义了四种类型的内部类：静态内部类 `StaticInnerClass`、成员内部类 `MemberInnerClass`、局部内部类 `LocalInnerClass` 和匿名内部类。通过外部类的实例，我们可以访问和使用这些内部类。

通过上述的示例，我们可以更好地理解和使用内部类，提高代码的灵活性和可读性。

##### 1.7.5 内部类的注意事项

在使用内部类时，需要注意以下几点：

- 内部类的访问修饰符可以控制其可见性。
- 内部类可以访问外部类的成员，包括私有成员。
- 内部类的实例必须依赖于外部类的实例。
- 内部类不能定义静态成员，但可以定义静态常量。
- 内部类可以实现接口和继承父类。
- 内部类的命名规范与外部类相同，但可以使用外部类的名称作为前缀进行区分。

使用内部类时，需要根据具体的需求和场景来选择适合的内部类类型，以实现代码的组织和封装。

#### 1.7 工具类

工具类是一种常用的类设计模式，用于封装一组相关的静态方法，这些方法通常是通用的、与特定对象无关的实用功能。

工具类的特点包括：

静态方法：工具类中的方法通常是静态方法，可以直接通过类名调用，无需创建对象。

- 不可实例化：工具类通常会将构造方法私有化，以防止被实例化。因为它们的目的是提供一组静态方法，而不是作为对象的容器。
- 无状态：工具类的静态方法通常不会维护任何状态信息，即不会改变类的成员变量。它们是无状态的，仅根据输入参数进行计算和处理。

工具类的应用场景包括：

- 提供通用的算法和函数：例如数学计算、日期时间处理、字符串操作等。
- 封装复杂的逻辑：例如数据校验、文件处理、网络请求等。
- 提供工具方法集合：例如集合操作、类型转换、文件路径处理等。

### 2. 封装

封装是面向对象编程的核心概念之一，它将数据和方法组合在一个单元中，形成类（Class）。封装通过隐藏对象的内部细节，提供了一种对外界隐藏实现细节的方式，使得对象的使用者只需要关注对象的公共接口，而无需了解对象的内部实现。

#### 2.1 封装的优势

封装提供了以下几个优势：

- **信息隐藏**：封装允许将对象的内部数据和方法隐藏起来，只暴露必要的接口给外部访问，从而保护对象的内部状态不受外部干扰。
- **提高安全性**：通过封装可以限制对对象的访问权限，只有通过指定的方法才能修改对象的状态，从而确保数据的安全性和一致性。
- **简化调用者的操作**：封装将复杂的内部实现细节隐藏起来，使得调用者只需调用简单的方法即可完成操作，提高了代码的可读性和可维护性。
- **提供代码重用**：通过定义可复用的类，可以在不同的项目中重用已封装好的对象和方法，减少代码的重复编写。

#### 2.2 访问控制修饰符

在Java中，访问控制修饰符用于控制类、方法和变量的访问权限。Java提供了四种访问控制修饰符：

- **public**：公共访问修饰符，可以被任何类访问。
- **private**：私有访问修饰符，只能在当前类内部访问。
- **protected**：受保护的访问修饰符，可以被同一包内的类以及子类访问。
- **默认（无修饰符）**：默认访问修饰符，只能在同一包内访问。

通过使用这些访问控制修饰符，可以控制类的成员（变量和方法）的可见性和访问权限，从而实现对类的封装。

#### 2.3 属性和方法的封装

在类的封装中，常用的做法是将类的属性（成员变量）声明为私有（private），并提供公共的方法（getter和setter）来访问和修改属性的值。这样做的好处是可以通过方法来控制对属性的访问，增加了对属性的保护和安全性。

示例：

```java
public class Person {
    private String name;
    private int age;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
        }
    
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("年龄不能为负数");
        }
    }
}
```

在上述示例中，`name`和`age`属性被声明为私有（`private`），外部无法直接访问。通过提供公共的getter和setter方法，可以实现对属性的访问和修改。在`setAge`方法中，还添加了对年龄的合法性进行检查，确保年龄不能为负数。

### 3. 继承

继承是面向对象编程中一种重要的概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，子类可以直接使用父类的属性和方法，并且还可以在此基础上进行扩展或重写。继承的概念提供了代码重用和层次化设计的能力。

#### 3.1 继承的语法

在 Java 中，使用 `extends` 关键字来实现类的继承。子类可以继承父类的非私有属性和方法，包括实例变量、静态变量、实例方法和静态方法。继承的语法如下：

```java
public class Subclass extends Superclass {
    // 子类的成员变量和方法
}
```

在上述代码中，`Subclass` 是子类的名称，`Superclass` 是父类的名称。子类可以通过继承获得父类的属性和方法，同时可以在子类中定义自己的新属性和方法。

#### 3.2 继承的特性

继承具有以下特性：

- **代码重用**：通过继承，子类可以重用父类的代码，避免重复编写相同的代码。
- **扩展性**：子类可以在继承的基础上添加新的属性和方法，以满足特定的需求。
- **方法重写**：子类可以重写父类的方法，以实现自己的逻辑。通过方法重写，子类可以改变父类方法的行为。
- **继承链**：Java 支持多层继承，即一个类可以继承另一个类的子类，形成继承的链式结构。
- **访问控制**：继承关系中，子类可以访问父类的公共和受保护的成员，但不能访问私有成员。

### 4.多态

多态是面向对象编程中的一个重要概念，它允许使用父类类型的引用变量来引用子类对象，从而实现代码的灵活性和可扩展性。多态性可以通过方法重写和继承关系来实现。

```java
public class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

public class Dog extends Animal {
    public void sound() {
        System.out.println("Dog wang");
    }
}

public class Cat extends Animal {
    public void sound() {
        System.out.println("Cat miao");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();

        animal1.sound(); // 输出：Dog wang
        animal2.sound(); // 输出：Cat miao
    }
}
```

在上述代码中，定义了一个父类 `Animal` 和两个子类 `Dog` 和 `Cat`。父类 `Animal` 中定义了 `sound()` 方法，子类 `Dog` 和 `Cat` 分别重写了该方法。在 `Main` 类中，通过父类变量分别引用 `Dog` 和 `Cat` 对象，并调用 `sound()` 方法。由于多态性的存在，根据对象的实际类型，调用相应子类的方法。

#### 4.1 多态的使用前提

要使用多态性，需要满足以下三个条件：

1. 继承关系：存在父类和子类之间的继承关系，子类继承了父类的属性和方法。

2. 方法重写：子类需要重写父类的方法，以实现自己的特定行为。方法的签名（名称、参数列表）必须与父类中被重写的方法相同。

3. 父类引用指向子类对象：将子类对象赋值给父类类型的引用变量，即向上转型。

#### 4.2 多态访问成员的特点

- 编译时类型与运行时类型不一致：编译时，变量被声明为父类类型，而运行时，实际引用的是子类对象。

- 成员访问以运行时类型为准：在多态情况下，成员变量的访问以编译时类型为准，而方法的访问以运行时类型为准。
  - 变量和静态成员：编译看左，运行看左

  - 方法：编译看左，运行看右

- 父类引用指向子类对象：可以使用父类类型的引用变量来引用子类对象。

- 方法重写实现动态绑定：多态性的关键是方法的重写。在运行时，根据对象的实际类型来确定调用哪个类的方法。

#### 4.3 向上转型和向下转型

- 向上转型（Upcasting）：向上转型是指将子类对象赋值给父类类型的引用变量。向上转型可以隐式地进行，不需要显式的类型转换操作。

- 向下转型（Downcasting）：向下转型是指将父类类型的引用变量转换为子类类型的引用变量。向下转型需要显式地进行，并且需要确保转换是安全的，即父类引用变量引用的对象实际上是子类对象。

  向下转型的语法格式：

  ```java
  SubClass subObj = (SubClass) superObj;
  ```

  向下转型的注意事项：

  - 转换过程中，需要确保父类引用变量引用的对象实际上是子类对象，否则会抛出`ClassCastException`异常。
  - 在进行向下转型之前，最好使用`instanceof`运算符进行类型检查，确保转换是安全的。

  向下转型的作用是恢复被向上转型的对象的真实类型，以便访问子类特有的成员变量和方法。

#### 4.4 方法重载和方法重写的多态性

多态性可以通过方法重载和方法重写来实现。

- 方法重载（Method Overloading）：方法重载是在同一个类中定义多个同名方法，但参数列表不同。在编译时根据参数类型和个数确定调用哪个方法。

- 方法重写（Method Overriding）：方法重写是子类重写父类中的方法，子类方法与父类方法具有相同的名称、返回类型和参数列表。在运行时根据实际对象类型确定调用哪个方法。

#### 4.5 抽象类和接口的多态性

抽象类和接口也可以实现多态性。

- 抽象类（Abstract Class）：抽象类是不能被实例化的，它只能作为其他类的父类来使用。通过抽象类可以定义抽象方法，子类必须实现这些抽象方法。抽象类的引用变量可以指向实际子类的对象。

- 接口（Interface）：接口定义了一组方法的规范，它是一种纯粹的抽象类，只包含抽象方法和常量的声明。实现接口的类必须实现接口中声明的所有方法。接口的引用变量可以指向实现了该接口的类的对象。

通过抽象类和接口的多态性，可以实现代码的灵活性和可扩展性。

#### 4.6 多态的应用场景

多态性在实际的软件开发中有广泛的应用，其中一些常见的应用场景包括：

- 代码复用：通过多态性可以编写通用的、可复用的代码，提高代码的可维护性和可读性。

- 扩展性：多态性可以方便地扩展程序功能，通过添加新的子类来实现新的功能，而不需要修改已有的代码。

- 运行时动态绑定：多态性实现了运行时动态绑定，根据实际对象类型来确定调用哪个方法，提供了更灵活的程序行为。

- 接口实现：多态性常用于接口的实现，通过接口引用变量来调用实现了该接口的类的方法。



### 5. 抽象类

抽象类是一种特殊的类，它不能被实例化，只能被继承。抽象类可以包含普通方法和抽象方法，其中抽象方法是没有实现的方法，需要在子类中进行具体实现。

#### 5.1 抽象类的定义和声明

在Java中，使用`abstract`关键字来定义抽象类。抽象类可以拥有普通方法和抽象方法。抽象类的定义格式如下：

```java
public abstract class ClassName {
    // 抽象类的成员变量和方法
}
```

#### 5.2 抽象方法

抽象方法是没有具体实现的方法，只有方法的声明，没有方法体。抽象方法用于定义子类必须实现的方法。

在抽象类中，使用`abstract`关键字来定义抽象方法。抽象方法的声明格式如下：

```java
public abstract void methodName();
```

#### 5.3 抽象类的特点

- 抽象类不能被实例化，只能作为其他类的父类来使用。
- 抽象类可以包含普通方法和抽象方法。
- 如果一个类继承了抽象类，那么它必须实现抽象类中的所有抽象方法，除非它自身也声明为抽象类。
- 抽象类可以拥有成员变量，构造方法和非抽象方法的实现。
- 抽象类的子类可以继续被其他类继承。

#### 5.4 抽象类的应用

抽象类主要用于定义一组相关的类的行为和规范。它常用于以下场景：

- 定义一组类的共同特征和行为，抽象类作为这组类的父类，可以提供一些通用的方法和属性。
- 定义接口的实现类，抽象类可以实现接口中的一部分方法，让子类只需实现剩余的方法。
- 作为框架设计的基础，抽象类提供了一些基本的功能和约束，具体实现由子类完成。

### 6. 接口

接口是一种完全抽象的类，它只包含常量和抽象方法的声明，没有具体实现。接口定义了一组方法的规范，实现接口的类必须实现接口中声明的所有方法。

#### 6.1 接口的定义和声明

在Java中，使用`interface`关键字来定义接口。接口中只包含常量和抽象方法的声明，没有具体实现。接口的定义格式如下：

```java
public interface InterfaceName {
    // 接口的常量声明
    
    // 接口的抽象方法声明
}
```

#### 6.2 接口的特点

- 接口中的方法都是抽象方法，没有具体实现。
- 接口中的常量默认为`public static final`类型的，可以直接通过接口名访问。
- 类可以实现多个接口，实现接口的类必须实现接口中声明的所有方法。
- 接口可以继承其他接口，使用`extends`关键字。

#### 6.3 接口的应用

接口主要用于定义一组类的行为和规范，它具有以下应用场景：

- 定义类的规范和行为，强制实现类遵循接口中声明的方法。
- 多态性的实现，通过接口类型引用对象，实现不同类的对象的统一调用。
- 定义回调方法，类实现接口并实现接口中的回调方法，供其他类调用。

接口在Java中广泛应用，是实现类与实现细节的解耦的重要手段之一。

### 7. 常用类

本节介绍一些常用的Java类，包括Object、Scanner、String、StringBuffer、Arrays、包装类和Random。

#### 7.1 Object

`java.lang.Object` 是所有类的父类，在Java中所有的类都直接或间接继承自`Object`类。

`Object`类提供了一些常用的方法：

- `equals()`： 比较对象的内容，可以根据自定义规则进行重写，用于判断对象是否相等。

  底层使用“==”，会比较对象的地址值。

- `hashCode()`:返回对象的hash值。

- `toString()`：以字符的形式打印对象的值，直接打印对象名便是调用此方法。

- `getClass`:获取当前类型。

- `finalize()`:手动垃圾回收。

- `clone()`:浅拷贝。

#### 7.2 Scanner

`java.util.Scanner` 类用于从标准输入、文件或字符串等来源读取输入数据。它提供了一系列的方法，如`nextInt()`、`nextDouble()`、`nextLine()`（可接收特殊字符）等，用于读取不同类型的输入数据。

#### 7.3 String

`java.lang.String` 类代表字符串。它是不可变的，一旦创建就不能被修改。

`String`类提供了许多用于操作字符串的方法：

- 长度获取：`length()`方法用于获取字符串的长度。
- 字符获取：`charAt(int index)`方法用于获取指定索引位置的字符。
- 字符串拼接：`concat(String str)`方法用于将指定字符串连接到原字符串的末尾。
- 子字符串提取：`substring(int beginIndex, int endIndex)`方法用于获取原字符串的子字符串。
- 字符串分割：`split(String regex)`方法用于将字符串按照指定的分隔符进行分割，并返回一个字符串数组。
- 字符串替换：`replace(char oldChar, char newChar)`方法用于将原字符串中的指定字符替换为新的字符。
- 字符串查找：`indexOf(String str)`方法用于在原字符串中查找指定字符串，并返回第一次出现的索引位置。

#### 7.4 StringBuffer

`java.lang.StringBuffer` 类用于可变字符串的操作。与`String`不同，`StringBuffer`对象的内容可以被修改。`StringBuffer`类提供了许多方法，用于在字符串中执行插入、追加、删除等操作。

- 构造方法
  - `StringBuffer()`: 创建一个空的`StringBuffer`对象。
  - `StringBuffer(int capacity)`: 创建一个指定容量的`StringBuffer`对象。
  - `StringBuffer(String str)`: 创建一个包含指定字符串的`StringBuffer`对象。

- 常用方法
  - `append(String str)`: 在字符串末尾追加指定字符串。
  - `insert(int offset, String str)`: 在指定位置插入指定字符串。
  - `delete(int start, int end)`: 删除指定范围内的字符。
  - `reverse()`: 反转字符串。
  - `replace(int start, int end, String str)`: 用指定字符串替换指定范围内的字符。
  - `length()`: 返回字符串的长度。
  - `capacity()`: 返回当前容量（可容纳的字符数）。
  - `toString()`: 将`StringBuffer`对象转换为字符串。


示例代码：

```java
// 创建一个空的StringBuffer对象
StringBuffer sb1 = new StringBuffer();

// 创建一个指定容量的StringBuffer对象
StringBuffer sb2 = new StringBuffer(16);

// 创建一个包含指定字符串的StringBuffer对象
StringBuffer sb3 = new StringBuffer("Hello");

// 在字符串末尾追加指定字符串
sb3.append(" World");

// 在指定位置插入指定字符串
sb3.insert(5, " Java");

// 删除指定范围内的字符
sb3.delete(5, 10);

// 反转字符串
sb3.reverse();

// 用指定字符串替换指定范围内的字符
sb3.replace(0, 5, "Hi");

// 获取字符串的长度
int length = sb3.length();

// 获取当前容量
int capacity = sb3.capacity();

// 将StringBuffer对象转换为字符串
String str = sb3.toString();
```

`StringBuffer`类的方法允许我们动态地修改字符串内容，可以用于频繁的字符串操作，如拼接、插入、删除和替换等。由于`StringBuffer`是可变的，它的性能比`String`更高效。

`StringBuffer` 是线程安全的类，需要注意的是，由于线程安全的机制，`StringBuffer` 在某些情况下的性能可能会受到影响。如果不需要线程安全的操作，可以使用非线程安全的 `StringBuilder` 类，它提供了类似的可变字符串操作，但没有同步开销。

#### 7.5 Arrays

`java.util.Arrays` 类提供了用于操作数组的各种方法，如排序、搜索、比较和填充等。

- 排序方法
  - `sort(array)`: 对数组进行升序排序。
  - `sort(array, fromIndex, toIndex)`: 对数组指定范围内的元素进行升序排序。
  - `parallelSort(array)`: 使用并行算法对数组进行升序排序。
  - `parallelSort(array, fromIndex, toIndex)`: 使用并行算法对数组指定范围内的元素进行升序排序。

- 搜索方法
  - `binarySearch(array, key)`: 使用二分查找算法在排序后的数组中搜索指定元素。
  - `binarySearch(array, fromIndex, toIndex, key)`: 使用二分查找算法在排序后的数组指定范围内搜索指定元素。

- 比较方法
  - `equals(array1, array2)`: 比较两个数组是否相等。
  - `deepEquals(array1, array2)`: 深度比较两个数组是否相等，会递归比较多维数组的元素。

- 填充方法
  - `fill(array, value)`: 将数组的所有元素都设置为指定的值。
  - `fill(array, fromIndex, toIndex, value)`: 将数组指定范围内的元素都设置为指定的值。

- 转换方法
  - `toString(array)`: 将数组转换为字符串形式。
  - `deepToString(array)`: 将多维数组转换为字符串形式。

- 数组操作方法
  - `copyOf(array, length)`: 复制指定长度的数组。
  - `copyOfRange(array, fromIndex, toIndex)`: 复制指定范围内的数组元素。
  - `asList(array)`: 将数组转换为`List`集合。


示例代码：

```java
int[] numbers = {5, 2, 8, 3, 1};

// 对数组进行升序排序
Arrays.sort(numbers);

// 在排序后的数组中搜索指定元素
int index = Arrays.binarySearch(numbers, 3);

// 比较两个数组是否相等
boolean isEqual = Arrays.equals(numbers, new int[]{1, 2, 3, 5, 8});

// 将数组的所有元素设置为指定的值
Arrays.fill(numbers, 0);

// 将数组转换为字符串形式
String str = Arrays.toString(numbers);

// 复制指定长度的数组
int[] copy = Arrays.copyOf(numbers, 3);

// 将数组转换为List集合
List<Integer> list = Arrays.asList(numbers);
```

`Arrays`类提供了丰富的方法来简化数组的操作。这些方法能够提高数组的排序、搜索、比较和填充等操作的效率和便利性。

#### 7.6 包装类

Java提供了与基本数据类型对应的包装类，用于将基本数据类型转换为对象。这些包装类包括`Boolean`、`Character`、`Byte`、`Short`、`Integer`、`Long`、`Float`和`Double`。包装类提供了一些常用的方法，如类型转换、比较大小等。

#### 7.7 Random

`java.util.Random` 类用于生成伪随机数。它提供了一系列的方法，如`nextInt()`、`nextDouble()`、`nextBoolean()`等，用于生成不同类型的随机数。

## 第三章：异常处理

异常处理是Java编程中重要的概念，它涉及到如何识别、捕获和处理程序运行过程中出现的错误情况。本章将介绍异常的概念、分类和处理机制，以及常见的异常类和一些异常处理的技巧和注意事项。

### 1. 异常的概念

异常是指程序在运行过程中遇到的意外情况或错误，它会导致程序的正常执行流程被中断。异常通常包含有关错误类型和错误发生位置的信息，帮助程序员定位和解决问题。

### 2. 异常的分类

异常按照其发生的时机和性质可以分为三种类型：

- 受检异常（`Checked Exception`）：在编译阶段就需要进行处理的异常，必须在代码中使用`try-catch`块或`throws`关键字进行处理。常见的受检异常有`IOException`、`ClassNotFoundException`等。
- 运行时异常（`Runtime Exception`）：在程序运行过程中可能出现的异常，不要求强制处理，可以选择性地进行处理。常见的运行时异常有`ArithmeticException`、`NullPointerException`等。
- 错误（`Error`）：指Java虚拟机无法解决的严重问题，通常是由系统资源耗尽或不可恢复的错误导致的。不需要对错误进行处理，程序无法从错误中恢复。

### 3. 异常处理的机制

异常处理机制主要包括以下几个部分：

#### 3.1 try-catch块

`try-catch`块用于捕获和处理异常。`try`块中包含可能抛出异常的代码，而`catch`块用于捕获并处理异常。`catch`块可以指定捕获特定类型的异常，并提供相应的处理逻辑。

#### 3.2 finally块

`finally`块用于定义无论是否发生异常都需要执行的代码。无论`try`块中是否发生异常，`finally`块中的代码都会被执行。通常在`finally`块中进行资源释放或清理操作。

#### 3.3 throw语句

`throw`语句用于手动抛出异常。通过`throw`语句可以在程序中显式地抛出指定的异常，以便由上层代码进行捕获和处理。

#### 3.4 throws关键字

`throws`关键字用于在方法声明中指定可能抛出的异常类型。当方法中可能抛出受检异常时，需要使用`throws`关键字声明异常类型，以便调用该方法的代码进行处理。

### 4. 自定义异常

Java允许用户自定义异常，以满足特定的业务需求。自定义异常需要继承自`Exception`或其子类，并根据需要添加额外的字段和方法。

### 5. 常见的异常类

Java提供了许多常见的异常类，用于表示不同类型的错误和异常情况。以下是几个常见的异常类及其说明：

#### 5.1 ArithmeticException

`ArithmeticException`是运行时异常，表示在数学运算过程中发生了算术错误，例如除以零。

#### 5.2 NullPointerException

`NullPointerException`是运行时异常，表示尝试访问空对象的成员或调用空对象的方法。

#### 5.3 ArrayIndexOutOfBoundsException

`ArrayIndexOutOfBoundsException`是运行时异常，表示数组访问越界，即尝试访问不存在的数组元素。

#### 5.4 IllegalArgumentException

`IllegalArgumentException`是运行时异常，表示方法接收到非法的参数。

#### 5.5 ClassNotFoundException

`ClassNotFoundException`是受检异常，表示尝试加载不存在的类。

#### 5.6 IOException

`IOException`是受检异常，表示输入输出操作中发生了错误，例如文件读写失败。

#### 5.7 Exception

`Exception`是Java中所有异常类的基类，它是受检异常的直接或间接父类。

### 6. 多重捕获和异常链

Java允许在一个`try-catch`块中捕获多个异常，并根据不同的异常类型执行相应的处理逻辑。可以使用多个`catch`块来处理不同类型的异常。

异常链是指在异常处理过程中，一个异常引发了另一个异常。可以使用异常的构造方法将原始异常作为参数传递给新的异常，并将其添加到异常链中，以便更好地追踪和定位问题。

### 7. 常用的异常处理技巧和注意事项

在处理异常时，以下是一些常用的技巧和注意事项：

- 选择合适的异常类型来捕获和处理，避免过于宽泛或过于具体的异常捕获。
- 在`catch`块中处理异常时，可以打印异常信息或记录日志，以便进行故障排查和调试。
- 使用`finally`块进行资源释放或清理操作，确保资源的正确关闭。
- 在捕获异常后，可以根据具体情况选择继续抛出异常、返回默认值或执行其他逻辑。
- 异常处理应当遵循程序设计的原则和规范，提高代码的可读性和可维护性。



### 第四章：集合

集合（Collections）是Java中常用的数据结构，用于存储和操作一组相关的数据元素。集合框架提供了一套强大而灵活的类和接口，用于处理各种类型的集合数据。本章将介绍Java集合框架的概念、常见的集合类和接口，以及集合的常用操作和技巧。

#### 1. 集合框架概述

集合框架（Collections Framework）是Java中用于存储和操作数据的一组类和接口。它提供了一套统一的编程接口，用于管理和操作不同类型的集合数据。集合框架的设计目标是提供高效、可靠和可扩展的集合实现，使开发人员能够更轻松地处理和操作数据。

##### 1.1 集合的作用和优势

集合框架在Java编程中具有重要的作用和优势：

- **数据存储和组织**：集合框架提供了多种集合类和接口，可以方便地存储和组织数据，例如列表、集合、映射等。
- **高性能和效率**：集合框架的实现经过优化，可以提供高性能的数据访问和操作。
- **类型安全**：通过使用泛型（Generic）技术，集合框架提供了类型安全的数据存储和操作，减少了类型转换的错误和麻烦。
- **代码重用**：集合框架提供了一套通用的接口和算法，可以方便地重用代码，减少了开发时间和工作量。
- **可扩展性**：集合框架的设计允许开发人员根据需要自定义和扩展集合类，以满足特定的业务需求。

##### 1.2 集合框架的体系结构

集合框架的体系结构是一个层次化结构，由一组接口和类组成，用于存储和操作不同类型的集合数据。下面是集合框架的体系结构概述：

- 根接口：`java.util.Collection`
  - `Collection`是集合框架的根接口，它定义了一组通用的方法，用于操作集合中的元素。
  - `Collection`接口的常见实现类包括`List`、`Set`、`Queue`和`Map`。

- 列表接口：`java.util.List`
  - `List`接口是一个有序的集合，可以包含重复元素。
  - `List`接口定义了有关元素的索引、插入、删除和访问的操作。
  - `List`接口的常见实现类包括`ArrayList`、`LinkedList`和`Vector`等。

- 集合接口：`java.util.Set`
  - `Set`接口是一个不允许包含重复元素的集合。
  - `Set`接口定义了添加、删除和检查元素是否存在的操作。
  - `Set`接口的常见实现类包括`HashSet`、`TreeSet`和`LinkedHashSet`等。

- 队列接口：`java.util.Queue`
  - `Queue`接口是一个用于操作队列数据结构的接口。
  - `Queue`接口定义了添加、删除和检查队列中的元素的操作。
  - `Queue`接口的常见实现类包括`LinkedList`和`PriorityQueue`等。

- 映射接口：`java.util.Map`
  - `Map`接口是一种键值对（key-value）映射的集合。
  - `Map`接口定义了添加、删除和检查键值对的操作。
  - `Map`接口的常见实现类包括`HashMap`、`TreeMap`和`LinkedHashMap`等。


集合框架的体系结构中，根接口`Collection`提供了最基本的集合操作，而列表接口`List`、集合接口`Set`、队列接口`Queue`和映射接口`Map`则分别针对不同的需求提供了特定的操作和功能。每个接口都有对应的实现类，开发人员可以根据具体需求选择适合的集合类来存储和操作数据。

此外，集合框架还包括一些抽象类和工具类，用于提供通用的实现和算法。例如，抽象类`AbstractCollection`和`AbstractList`提供了部分集合功能的实现细节，而工具类`Collections`提供了集合操作的工具方法，如排序、搜索等。

#### 2. 泛型与集合

##### 2.1 泛型的概念和作用

- 泛型（Generics）是Java引入的一种类型参数化机制，用于增强代码的类型安全性和重用性。

- 泛型的作用：

  - 提供编译时的类型检查，避免在运行时出现类型错误。
  - 使代码更加通用和灵活，可适用于不同类型的数据。
  - 提供编译时的类型推断，减少类型转换的繁琐和风险。

- 示例代码：

  ```java
  // 声明一个泛型类
  class Box<T> {
    private T item;
    
    public void setItem(T item) {
      this.item = item;
    }
    
    public T getItem() {
      return item;
    }
  }
  
  // 使用泛型类
  Box<String> stringBox = new Box<>();
  stringBox.setItem("Hello");
  String str = stringBox.getItem();
  ```

##### 2.2 泛型集合类和接口

- Java提供了许多泛型集合类和接口，用于存储和操作各种类型的数据。

- 常见的泛型集合类和接口包括：

  - `ArrayList<E>`: 动态数组，可变长度的列表。
  - `LinkedList<E>`: 双向链表，适用于频繁的插入和删除操作。
  - `HashSet<E>`: 基于哈希表实现的无序集合，不允许重复元素。
  - `TreeSet<E>`: 基于红黑树实现的有序集合，不允许重复元素。
  - `HashMap<K, V>`: 基于哈希表实现的键值对映射。
  - `TreeMap<K, V>`: 基于红黑树实现的有序键值对映射。

- 示例代码：

  ```java
  List<String> list = new ArrayList<>();
  list.add("Apple");
  list.add("Banana");
  
  Set<Integer> set = new HashSet<>();
  set.add(1);
  set.add(2);
  
  Map<String, Integer> map = new HashMap<>();
  map.put("Apple", 1);
  map.put("Banana", 2);
  ```

##### 2.3 使用泛型提高类型安全性

- 泛型可以提高代码的类型安全性，避免在编译时和运行时出现类型错误。

- 使用泛型的好处：

  - 编译器可以进行类型检查，确保只有兼容的类型可以传递给泛型类或方法。
  - 避免了在运行时进行类型转换，减少了出现类型转换异常的风险。
  - 提供了更好的代码可读性和可维护性，明确了代码中的数据类型。

- 示例代码：

  ```java
  // 泛型类
  class Box<T> {
      private T item;
      
      public void setItem(T item) {
          this.item = item;
      }
      
      public T getItem() {
          return item;
      }
  }
  
  // 泛型方法
  public <E> void printList(List<E> list) {
      for (E item : list) {
          System.out.println(item);
      }
  }
  
  // 使用泛型类和泛型方法
  Box<String> stringBox = new Box<>();
  stringBox.setItem("Hello");
  String str = stringBox.getItem();
  
  List<Integer> intList = new ArrayList<>();
  intList.add(1);
  intList.add(2);
  printList(intList);
  
  ```

#### 3. 集合接口的成员方法

##### 3.1 Collection 接口的成员方法

- `boolean add(E element)`: 将指定的元素添加到集合中。
- `boolean addAll(Collection<? extends E> collection)`: 将指定集合中的所有元素添加到当前集合中。
- `void clear()`: 清空集合中的所有元素。
- `boolean contains(Object object)`: 判断集合中是否包含指定的元素。
- `boolean containsAll(Collection<?> collection)`: 判断集合是否包含指定集合中的所有元素。
- `boolean isEmpty()`: 判断集合是否为空。
- `Iterator<E> iterator()`: 返回在集合上进行迭代的迭代器。
- `boolean remove(Object object)`: 从集合中移除指定的元素。
- `boolean removeAll(Collection<?> collection)`: 从集合中移除包含在指定集合中的所有元素。
- `boolean retainAll(Collection<?> collection)`: 保留集合中与指定集合相同的元素，移除其他元素。
- `int size()`: 返回集合中的元素个数。
- `Object[] toArray()`: 将集合转换为对象数组。
- `<T> T[] toArray(T[] array)`: 将集合转换为指定类型的数组。

##### 3.2 List 接口的成员方法

除了继承自 Collection 接口的方法外，List 接口还定义了以下方法：

- `void add(int index, E element)`: 在指定的索引位置插入元素。
- `boolean addAll(int index, Collection<? extends E> collection)`: 在指定的索引位置插入指定集合中的所有元素。
- `E get(int index)`: 返回指定索引位置的元素。
- `int indexOf(Object object)`: 返回元素第一次出现的索引，若不存在返回 -1。
- `int lastIndexOf(Object object)`: 返回元素最后一次出现的索引，若不存在返回 -1。
- `ListIterator<E> listIterator()`: 返回列表元素的双向迭代器。
- `ListIterator<E> listIterator(int index)`: 返回从指定索引开始的列表元素的双向迭代器。
- `E remove(int index)`: 移除指定索引位置的元素。
- `E set(int index, E element)`: 将指定索引位置的元素替换为新元素。
- `List<E> subList(int fromIndex, int toIndex)`: 返回指定索引范围内的子列表。

##### 3.3 Set 接口的成员方法

除了继承自 Collection 接口的方法外，Set 接口还定义了以下方法：

- `boolean add(E element)`: 将指定的元素添加到集合中。
- `boolean addAll(Collection<? extends E> collection)`: 将指定集合中的所有元素添加到当前集合中。
- `boolean contains(Object object)`: 判断集合中是否包含指定的元素。
- `boolean containsAll(Collection<?> collection)`: 判断集合是否包含指定集合中的所有元素。
- `boolean remove(Object object)`: 从集合中移除指定的元素。
- `boolean removeAll(Collection<?> collection)`: 从集合中移除包含在指定集合中的所有元素。
- `boolean retainAll(Collection<?> collection)`: 保留集合中与指定集合相同的元素，移除其他元素。
- `int size()`: 返回集合中的元素个数。
- `void clear()`: 清空集合中的所有元素。
- `boolean isEmpty()`: 判断集合是否为空。
- `Iterator<E> iterator()`: 返回在集合上进行迭代的迭代器。

##### 3.4 Queue 接口的成员方法

除了继承自 Collection 接口的方法外，Queue 接口还定义了以下方法：

- `boolean add(E element)`: 将指定的元素添加到队列中。
- `boolean offer(E element)`: 将指定的元素添加到队列中。
- `E remove()`: 移除并返回队列头部的元素。
- `E poll()`: 移除并返回队列头部的元素，若队列为空则返回 null。
- `E element()`: 返回队列头部的元素，但不移除。
- `E peek()`: 返回队列头部的元素，若队列为空则返回 null。

##### 3.5 Map 接口的成员方法

- `void clear()`: 清空映射中的所有键值对。
- `boolean containsKey(Object key)`: 判断映射中是否包含指定的键。
- `boolean containsValue(Object value)`: 判断映射中是否包含指定的值。
- `Set<Map.Entry<K, V>> entrySet()`: 返回包含映射中所有键值对的 Set 视图。
- `V get(Object key)`: 返回与指定键关联的值，若键不存在则返回 null。
- `boolean isEmpty()`: 判断映射是否为空。
- `Set<K> keySet()`: 返回包含映射中所有键的 Set 视图。
- `V put(K key, V value)`: 将指定的键值对添加到映射中，若键已存在则替换值并返回旧值。
- `void putAll(Map<? extends K, ? extends V> map)`: 将指定映射中的所有键值对添加到当前映射中。
- `V remove(Object key)`: 移除并返回与指定键关联的值，若键不存在则返回 null。
- `int size()`: 返回映射中的键值对数量。
- `Collection<V> values()`: 返回包含映射中所有值的 Collection 视图。

#### 4. 常用的集合类

在Java的集合框架中，有多种常用的集合类可供选择，每种集合类都有其特定的用途和适用场景。下面介绍了常用的集合类及其特点。

##### 4.1 ArrayList

- `ArrayList`是基于数组实现的动态数组，它可以根据需要自动扩容。
- 特点：
  - 可以快速访问指定位置的元素，时间复杂度为O(1)。
  - 在末尾进行插入和删除操作的性能较好，时间复杂度为O(1)。
  - 在中间插入和删除元素时需要移动其他元素，性能较差，时间复杂度为O(n)。
  - 不适合频繁的插入和删除操作。
- 示例代码：
  ```java
  List<String> arrayList = new ArrayList<>();
  arrayList.add("Apple");
  arrayList.add("Banana");
  arrayList.add("Orange");
  ```

##### 4.2 LinkedList

- `LinkedList`是基于链表实现的双向链表，它可以高效地进行插入和删除操作。
- 特点：
  - 在任意位置进行插入和删除操作的性能较好，时间复杂度为O(1)。
  - 随机访问元素时需要遍历链表，性能较差，时间复杂度为O(n)。
  - 适合频繁的插入和删除操作。
- 示例代码：
  ```java
  List<String> linkedList = new LinkedList<>();
  linkedList.add("Apple");
  linkedList.add("Banana");
  linkedList.add("Orange");
  ```

##### 4.3 HashSet

- `HashSet`是基于哈希表实现的无序集合，它使用哈希函数来存储和查找元素。
- 特点：
  - 元素无序，不重复。
  - 添加、删除和查找操作的性能较好，平均时间复杂度为O(1)。
  - 不保证元素的顺序，不适用于有序操作。
- 示例代码：
  ```java
  Set<String> hashSet = new HashSet<>();
  hashSet.add("Apple");
  hashSet.add("Banana");
  hashSet.add("Orange");
  ```

##### 4.4 TreeSet

- `TreeSet`是基于红黑树（平衡二叉树）实现的有序集合，它可以自动按照元素的自然顺序进行排序。
- 特点：
  - 元素有序，不重复。
  - 添加、删除和查找操作的性能较好，平均时间复杂度为O(log n)。
  - 支持自定义排序规则。
- 示例代码：
  ```java
  Set<String> treeSet = new TreeSet<>();
  treeSet.add("Apple");
  treeSet.add("Banana");
  treeSet.add("Orange");
  ```

##### 4.5 HashMap

- `HashMap`是基于哈希表实现的键值对映射，它使用哈希函数来存储和查找键值对。

  - 特点：
    - 键值对无序，键不重复。
    - 添加、删除和查找操作的性能较好，平均时间复杂度为O(1)。
    - **允许使用null作为键和值。**
  - 示例代码：
    ```java
    Map<String, Integer> hashMap = new HashMap<>();
    hashMap.put("Apple", 1);
    hashMap.put("Banana", 2);
    hashMap.put("Orange", 3);
    ```


##### 4.6 Hashtable

- `Hashtable`是基于哈希表实现的键值对映射，类似于`HashMap`，但它是线程安全的。

- 特点：

  - 键值对无序，键不重复。
  - 添加、删除和查找操作的性能较好，平均时间复杂度为O(1)。
  - 线程安全，适用于多线程环境。

- 示例代码：

  ```java
  Map<String, Integer> hashtable = new Hashtable<>();
  hashtable.put("Apple", 1);
  hashtable.put("Banana", 2);
  hashtable.put("Orange", 3);
  ```

##### 4.7 TreeMap

- `TreeMap`是基于红黑树（平衡二叉树）实现的有序键值对映射，它可以自动按照键的自然顺序进行排序。
- 特点：
  - 键值对有序，键不重复。
  - 添加、删除和查找操作的性能较好，平均时间复杂度为O(log n)。
  - 支持自定义键的排序规则。
- 示例代码：
  ```java
  Map<String, Integer> treeMap = new TreeMap<>();
  treeMap.put("Apple", 1);
  treeMap.put("Banana", 2);
  treeMap.put("Orange", 3);
  ```



#### 5. 集合的常用操作

##### 5.1 遍历集合

- 遍历集合是指逐个访问集合中的元素。
- 常见的遍历方式包括使用迭代器（Iterator）、增强型for循环和Java 8引入的流（Stream）。
- 示例代码：
  ```java
  List<String> list = new ArrayList<>();
  list.add("Apple");
  list.add("Banana");
  
  // 使用迭代器遍历
  Iterator<String> iterator = list.iterator();
  while (iterator.hasNext()) {
      String item = iterator.next();
      System.out.println(item);
  }
  
  // 使用增强型for循环遍历
  for (String item : list) {
      System.out.println(item);
  }
  
  // 使用流遍历
  list.stream().forEach(System.out::println);
  ```

##### 5.2 集合的排序

- 对集合进行排序是指将集合中的元素按照特定的排序规则进行排序。
- 集合的排序通常使用`Collections.sort()`方法（对List集合进行排序）或`Arrays.sort()`方法（对数组进行排序）。
- 需要注意的是，被排序的元素必须实现`Comparable`接口，或者提供自定义的比较器（Comparator）。
- 示例代码：
  ```java
  List<Integer> numbers = new ArrayList<>();
  numbers.add(5);
  numbers.add(2);
  numbers.add(8);
  
  // 对List集合进行自然排序
  Collections.sort(numbers);
  System.out.println(numbers); // 输出：[2, 5, 8]
  
  // 对List集合使用自定义的比较器进行排序
  Collections.sort(numbers, new CustomComparator());
  System.out.println(numbers); // 输出：[8, 5, 2]
  ```

##### 5.3 集合的查找和替换

- 集合的查找和替换操作是指在集合中查找指定的元素或者替换集合中的某个元素。
- 常见的查找和替换方法包括使用`contains()`方法判断元素是否存在，使用`indexOf()`方法查找元素的位置，使用`get()`方法获取指定位置的元素，使用`set()`方法替换指定位置的元素等。
- 示例代码：
  ```java
  List<String> fruits = new ArrayList<>();
  fruits.add("Apple");
  fruits.add("Banana");
  fruits.add("Orange");
  
  // 判断集合中是否包含指定元素
  boolean containsApple = fruits.contains("Apple");
  System.out.println(containsApple); // 输出：true
  
  // 查找元素的位置
  int indexOfBanana = fruits.indexOf("Banana");
  System.out.println(indexOfBanana); // 输出：1
  
  // 获取指定位置的元素
  String fruit = fruits.get(2);
  System.out.println(fruit); // 输出：Orange
  
  // 替换指定位置的元素
  fruits.set(0, "Mango");
  System.out.println(fruits); // 输出：[Mango, Banana, Orange]
  ```

##### 5.4 集合的过滤和筛选

集合的过滤和筛选是指根据特定的条件从集合中选择符合条件的元素或者剔除不符合条件的元素。

可以使用循环遍历集合的方式，结合条件判断语句，筛选出符合条件的元素。示例代码如下：

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(4);
numbers.add(5);

List<Integer> evenNumbers = new ArrayList<>();
for (Integer number : numbers) {
    if (number % 2 == 0) {
        evenNumbers.add(number);
    }
}

System.out.println(evenNumbers); // 输出：[2, 4]
```

##### 5.5 集合的转换和拷贝

集合的转换和拷贝操作是指将一个集合转换为另一个类型的集合，或者将一个集合的元素拷贝到另一个集合中。

###### 5.5.1 使用构造方法进行集合转换和拷贝

可以使用集合类的构造方法来进行集合的转换和拷贝操作，通过传入另一个集合作为参数，将一个集合转换为另一个类型的集合，或者将一个集合的元素拷贝到另一个集合中。示例代码如下：

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(4);
numbers.add(5);

Set<Integer> numberSet = new HashSet<>(numbers); // 将List转换为Set
List<Integer> copiedList = new ArrayList<>(numbers); // 拷贝List集合

System.out.println(numberSet); // 输出：[1, 2, 3, 4, 5]
System.out.println(copiedList); // 输出：[1, 2, 3, 4, 5]
```

###### 5.5.2 使用Collections类的方法进行集合转换和拷贝

Collections类提供了一些方法用于集合的转换和拷贝，如`addAll()`方法和`addAll()`方法可以将一个集合的元素添加到另一个集合中。示例代码如下：

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(4);
numbers.add(5);

List<Integer> newNumbers = new ArrayList<>();

// 将numbers集合中大于2的元素添加到newNumbers集合中
for (Integer number : numbers) {
    if (number > 2) {
        newNumbers.add(number);
    }
}

System.out.println(newNumbers); // 输出：[3, 4, 5]
```

##### 5.6 集合的合并和分割

集合的合并和分割操作是指将多个集合合并为一个集合，或者将一个集合分割为多个子集合。

###### 5.6.1 合并集合

可以使用`addAll()`方法将一个集合的元素添加到另一个集合中，从而实现集合的合并操作。示例代码如下：

```java
List<Integer> list1 = new ArrayList<>();
list1.add(1);
list1.add(2);
list1.add(3);

List<Integer> list2 = new ArrayList<>();
list2.add(4);
list2.add(5);
list2.add(6);

List<Integer> mergedList = new ArrayList<>();
mergedList.addAll(list1);
mergedList.addAll(list2);

System.out.println(mergedList); // 输出：[1, 2, 3, 4, 5, 6]
```

###### 5.6.2 分割集合

可以使用`subList()`方法将一个集合按照指定的索引范围分割成多个子集合。示例代码如下：

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(4);
numbers.add(5);

List<Integer> subList1 = numbers.subList(0, 3);
List<Integer> subList2 = numbers.subList(3, 5);

System.out.println(subList1); // 输出：[1, 2, 3]
System.out.println(subList2); // 输出：[4, 5]
```

注意：通过`subList()`方法得到的子列表与原列表是关联的，对子列表的修改会影响原列表，同样，对原列表的修改也会影响子列表。

### 第五章：文件和IO流

#### 1文件和目录的基本概念

#### 2文件操作 

##### 2.1 创建文件 

##### 2.2 删除文件 

##### 2.3 重命名文件 

##### 2.4 文件属性的获取和修改

#### 3目录操作 

##### 3.1 创建目录 

##### 3.2 删除目录 

##### 3.3 列出目录内容

#### 4字节流和字符流的概念

#### 5字节流的操作 

##### 5.1 字节输入流 

###### 5.1.1 FileInputStream 

###### 5.1.2 BufferedInputStream 

##### 5.2 字节输出流 

###### 5.2.1 FileOutputStream 

###### 5.2.2 BufferedOutputStream

#### 6字符流的操作 

##### 6.1 字符输入流 

###### 6.1.1 FileReader 

###### 6.1.2 BufferedReader 

##### 6.2 字符输出流 

###### 6.2.1 FileWriter 

###### 6.2.2 BufferedWriter

#### 7对象的序列化和反序列化

#### 8文件和IO流的异常处理 

#### 9文件和IO流的最佳实践和注意事项

### 多线程

- 线程的概念
- 创建线程的方式
- 线程的生命周期
- 线程同步和互斥
- 线程池

### 数据库连接和操作

- JDBC概述
- 连接数据库
- 执行SQL语句
- 事务处理
